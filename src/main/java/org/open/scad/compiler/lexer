package org.open.scad.compiler;

import static org.open.scad.compiler.Parser.*;

%%
%public
%class Lexer
%implements Parser.yyInput
%{

  public boolean advance() throws java.io.IOException {
      Token t = yylex();
      if (t == null) {
          return false;
      }
      value = t.getValue();
      token = t.getToken();
      return (token != YY_EOF);
  }

  /**
   * returned by {@link #token()}.
   */

  protected int token;
  /**
   * returned by {@link #value()}.
   */
  protected Object value;
  /** current input symbol.
    */

  public int token() {
      return token;
  }

  /** null or string associated with current input symbol.
    */
  public Object value() {
      return value;
  }

  /** position for error message.
    */
  public String toString() { return "Error line: " + (yyline + 1); }
%}

%type Token
%line
%eofval{
  return new Token(YY_EOF, "EOF");
%eofval}

DIGIT=		[0-9]
LETTER=		[a-zA-Z]
WHITESPACE=	[ \t\n\r]      // space, tab, newline

%%

{LETTER}({LETTER}|{DIGIT}*) {System.out.println("line id " + (yyline + 1)); return new Token(1, yytext());}
{DIGIT}+                    {System.out.println("line dg " + (yyline + 1)); return new Token(2, yytext());}
"="                         {System.out.println("line as " + (yyline + 1)); return new Token(3, yytext());}
"=="                        {System.out.println("line eq " + (yyline + 1)); return new Token(4, yytext());}
{WHITESPACE}*               { }
.               	    {System.out.println(yyline+1 + ": bad char");  return new Token(5, yytext());}
"\x03" { return new Token(YY_EOF, yytext());}
